<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MNIST Digit Recognizer</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useRef, useEffect } = React;

    function MNISTDrawer() {
      const canvasRef = useRef(null);
      const previewRef = useRef(null);
      const [isDrawing, setIsDrawing] = useState(false);
      const [prediction, setPrediction] = useState(null);
      const [serverUrl, setServerUrl] = useState('http://localhost:8080/predict');
      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState(null);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (canvas) {
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 25;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
        }
      }, []);

      const startDrawing = (e) => {
        setIsDrawing(true);
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        ctx.beginPath();
        ctx.moveTo(x, y);
      };

      const draw = (e) => {
        if (!isDrawing) return;
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        ctx.lineTo(x, y);
        ctx.stroke();
      };

      const stopDrawing = () => {
        setIsDrawing(false);
      };

      const clearCanvas = () => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        const preview = previewRef.current;
        if (preview) {
          const pCtx = preview.getContext('2d');
          pCtx.fillStyle = 'white';
          pCtx.fillRect(0, 0, preview.width, preview.height);
        }
        
        setPrediction(null);
        setError(null);
      };

      const getBoundingBox = (imageData, width, height) => {
        let minX = width, minY = height, maxX = 0, maxY = 0;
        
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const i = (y * width + x) * 4;
            const avg = (imageData[i] + imageData[i + 1] + imageData[i + 2]) / 3;
            if (avg < 250) {
              minX = Math.min(minX, x);
              minY = Math.min(minY, y);
              maxX = Math.max(maxX, x);
              maxY = Math.max(maxY, y);
            }
          }
        }
        
        return { minX, minY, maxX, maxY };
      };

      const getCenterOfMass = (imageData, width, height, bbox) => {
        let totalMass = 0;
        let comX = 0;
        let comY = 0;
        
        for (let y = bbox.minY; y <= bbox.maxY; y++) {
          for (let x = bbox.minX; x <= bbox.maxX; x++) {
            const i = (y * width + x) * 4;
            const avg = (imageData[i] + imageData[i + 1] + imageData[i + 2]) / 3;
            const mass = 255 - avg;
            totalMass += mass;
            comX += x * mass;
            comY += y * mass;
          }
        }
        
        if (totalMass === 0) return { x: width / 2, y: height / 2 };
        
        return {
          x: comX / totalMass,
          y: comY / totalMass
        };
      };

      const applyGaussianBlur = (imageData, width, height) => {
        const output = new Uint8ClampedArray(imageData.length);
        
        // Simple 3x3 Gaussian kernel
        const kernel = [
          [1, 2, 1],
          [2, 4, 2],
          [1, 2, 1]
        ];
        const kernelSum = 16;
        
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let sum = 0;
            
            for (let ky = -1; ky <= 1; ky++) {
              for (let kx = -1; kx <= 1; kx++) {
                const py = Math.min(Math.max(y + ky, 0), height - 1);
                const px = Math.min(Math.max(x + kx, 0), width - 1);
                const i = (py * width + px) * 4;
                const weight = kernel[ky + 1][kx + 1];
                sum += imageData[i] * weight;
              }
            }
            
            const i = (y * width + x) * 4;
            const blurred = sum / kernelSum;
            output[i] = output[i + 1] = output[i + 2] = blurred;
            output[i + 3] = 255;
          }
        }
        
        return output;
      };

      const getImageData = () => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        
        // Get the drawing from the main canvas
        const drawingData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const bbox = getBoundingBox(drawingData.data, canvas.width, canvas.height);
        
        // Calculate dimensions
        const drawnWidth = bbox.maxX - bbox.minX + 1;
        const drawnHeight = bbox.maxY - bbox.minY + 1;
        
        // Create a temporary canvas for the cropped digit
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = drawnWidth;
        tempCanvas.height = drawnHeight;
        const tempCtx = tempCanvas.getContext('2d');
        
        // Copy just the drawn region
        tempCtx.putImageData(
          ctx.getImageData(bbox.minX, bbox.minY, drawnWidth, drawnHeight),
          0, 0
        );
        
        // Calculate center of mass in the cropped image
        const croppedData = tempCtx.getImageData(0, 0, drawnWidth, drawnHeight);
        const com = getCenterOfMass(croppedData.data, drawnWidth, drawnHeight, 
          { minX: 0, minY: 0, maxX: drawnWidth - 1, maxY: drawnHeight - 1 });
        
        // Determine scale to fit in 20x20 box
        const scale = Math.min(20 / drawnWidth, 20 / drawnHeight);
        const scaledWidth = drawnWidth * scale;
        const scaledHeight = drawnHeight * scale;
        
        // Create intermediate canvas for smooth scaling
        const intermediateCanvas = document.createElement('canvas');
        intermediateCanvas.width = scaledWidth;
        intermediateCanvas.height = scaledHeight;
        const intermediateCtx = intermediateCanvas.getContext('2d');
        
        // Enable high-quality image smoothing
        intermediateCtx.imageSmoothingEnabled = true;
        intermediateCtx.imageSmoothingQuality = 'high';
        
        // Draw scaled version
        intermediateCtx.drawImage(tempCanvas, 0, 0, scaledWidth, scaledHeight);
        
        // Create final 28x28 canvas
        const finalCanvas = document.createElement('canvas');
        finalCanvas.width = 28;
        finalCanvas.height = 28;
        const finalCtx = finalCanvas.getContext('2d');
        
        // Fill with white
        finalCtx.fillStyle = 'white';
        finalCtx.fillRect(0, 0, 28, 28);
        
        // Enable high-quality smoothing for final placement
        finalCtx.imageSmoothingEnabled = true;
        finalCtx.imageSmoothingQuality = 'high';
        
        // Calculate where to place the scaled image so COM is at center (14, 14)
        const comXScaled = com.x * scale;
        const comYScaled = com.y * scale;
        const offsetX = 14 - comXScaled;
        const offsetY = 14 - comYScaled;
        
        // Draw the scaled image centered by center of mass
        finalCtx.drawImage(intermediateCanvas, offsetX, offsetY);
        
        // Apply Gaussian blur to match MNIST smoothness
        let imageData = finalCtx.getImageData(0, 0, 28, 28);
        const blurredData = applyGaussianBlur(imageData.data, 28, 28);
        imageData.data.set(blurredData);
        finalCtx.putImageData(imageData, 0, 0);
        
        // Apply one more light blur
        imageData = finalCtx.getImageData(0, 0, 28, 28);
        const blurredData2 = applyGaussianBlur(imageData.data, 28, 28);
        imageData.data.set(blurredData2);
        finalCtx.putImageData(imageData, 0, 0);
        
        // Show preview
        const preview = previewRef.current;
        if (preview) {
          const pCtx = preview.getContext('2d');
          pCtx.imageSmoothingEnabled = false;
          pCtx.clearRect(0, 0, preview.width, preview.height);
          pCtx.drawImage(finalCanvas, 0, 0, preview.width, preview.height);
        }
        
        // Extract and normalize pixel data
        imageData = finalCtx.getImageData(0, 0, 28, 28);
        const pixels = imageData.data;
        
        const normalized = [];
        for (let i = 0; i < pixels.length; i += 4) {
          const avg = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
          normalized.push(1.0 - (avg / 255.0));
        }
        
        return normalized;
      };

      const sendToServer = async () => {
        if (!serverUrl) {
          setError('Please enter a server URL');
          return;
        }

        setIsLoading(true);
        setError(null);
        
        try {
          const imageData = getImageData();
          const response = await fetch(serverUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ image: imageData }),
          });

          if (!response.ok) {
            throw new Error(`Server responded with ${response.status}`);
          }

          const result = await response.json();
          setPrediction(result);
        } catch (err) {
          setError(err.message);
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-8">
          <div className="max-w-3xl mx-auto">
            <h1 className="text-4xl font-bold text-center mb-2 text-gray-800">
              MNIST Digit Recognizer
            </h1>
            <p className="text-center text-gray-600 mb-8">
              Draw a digit (0-9) and let the model predict it
            </p>

            <div className="bg-white rounded-lg shadow-xl p-6 mb-6">
              <div className="mb-4">
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Server URL
                </label>
                <input
                  type="text"
                  value={serverUrl}
                  onChange={(e) => setServerUrl(e.target.value)}
                  placeholder="http://localhost:5000/predict"
                  className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
                />
              </div>

              <div className="flex gap-6 justify-center mb-4">
                <div className="text-center">
                  <div className="text-sm font-medium text-gray-700 mb-2">
                    Draw here
                  </div>
                  <canvas
                    ref={canvasRef}
                    width={280}
                    height={280}
                    onMouseDown={startDrawing}
                    onMouseMove={draw}
                    onMouseUp={stopDrawing}
                    onMouseLeave={stopDrawing}
                    className="border-4 border-gray-300 rounded-lg cursor-crosshair shadow-inner"
                    style={{ touchAction: 'none' }}
                  />
                </div>
                
                <div className="text-center">
                  <div className="text-sm font-medium text-gray-700 mb-2">
                    Processed (28×28)
                  </div>
                  <canvas
                    ref={previewRef}
                    width={280}
                    height={280}
                    className="border-4 border-gray-300 rounded-lg shadow-inner bg-white"
                  />
                </div>
              </div>

              <div className="flex gap-3 justify-center mb-6">
                <button
                  onClick={clearCanvas}
                  className="flex items-center gap-2 px-6 py-3 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors font-medium"
                >
                  Clear
                </button>
                <button
                  onClick={sendToServer}
                  disabled={isLoading}
                  className="flex items-center gap-2 px-6 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors font-medium disabled:bg-indigo-300 disabled:cursor-not-allowed"
                >
                  {isLoading ? 'Predicting...' : 'Predict'}
                </button>
              </div>

              {error && (
                <div className="p-4 bg-red-50 border border-red-200 rounded-lg text-red-700">
                  <strong>Error:</strong> {error}
                </div>
              )}

              {prediction && (
                <div className="p-6 bg-gradient-to-r from-green-50 to-emerald-50 border-2 border-green-200 rounded-lg">
                  <h3 className="text-lg font-semibold text-gray-800 mb-2">
                    Prediction Result:
                  </h3>
                  <pre className="bg-white p-4 rounded border border-gray-200 overflow-auto text-sm">
                    {JSON.stringify(prediction, null, 2)}
                  </pre>
                </div>
              )}
            </div>

            <div className="bg-white rounded-lg shadow-md p-4 text-sm text-gray-600">
              <h4 className="font-semibold mb-2">MNIST-style preprocessing applied:</h4>
              <ul className="list-disc list-inside space-y-1">
                <li>Bounding box detection and cropping</li>
                <li>Center of mass calculation</li>
                <li>Aspect-preserving scale to fit 20×20 box</li>
                <li>Center of mass positioned at (14, 14)</li>
                <li>High-quality anti-aliasing during scaling</li>
                <li>Gaussian blur applied twice for smooth edges (like MNIST)</li>
                <li>Final 28×28 grayscale normalization (0.0-1.0)</li>
              </ul>
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.render(<MNISTDrawer />, document.getElementById('root'));
  </script>
</body>
</html>